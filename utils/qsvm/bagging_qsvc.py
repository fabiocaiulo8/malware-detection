from sklearn.base import BaseEstimator
from sklearn.svm import SVC
import numpy as np
import jax
import pennylane as qml
from pennylane.templates import AngleEmbedding

class BaggingQSVC(BaseEstimator):

    def __init__(
        self,
        base_estimator=SVC(kernel='precomputed', probability=True),
        estimators=10,
        samples=500,
        features=5,
        random_state=42,
        classes_=[-1, 1]
    ):
        self.base_estimator = base_estimator
        if type(base_estimator) is not type(SVC()) and base_estimator.kernel != 'precomputed' and base_estimator.probability is not True:
            raise RuntimeError('Only SVC with precomputed kernel and probability prediction estimates enabled is supported as base estimator')
        self.estimators = estimators
        self.samples = samples
        self.features = features

        np.random.seed(random_state)
        jax.random.PRNGKey(random_state)
        self.classes_ = classes_
        if len(self.classes_) != 2:
            raise RuntimeError('Only binary classification is supported')

        self.X_train = None
        self.sample_indices = None
        self.feature_indices = None
        self.projector = None
        self.ensemble_estimator = []

    def get_params(self, deep=True):
        return {
            'base_estimator': self.base_estimator,
            'estimators': self.estimators,
            'samples': self.samples,
            'features': self.features
        }

    def set_params(self, **params):
        for parameter, value in params.items():
            setattr(self, parameter, value)
        return self

    def _quantum_kernel(self):
        """
        SVM Quantum Kernel
        """
        @qml.qnode(qml.device('default.qubit', self.features), interface='jax', diff_method='backprop')
        def quantum_circuit(x1, x2):
            AngleEmbedding(x1, range(self.features))
            qml.adjoint(AngleEmbedding)(x2, range(self.features))
            return qml.expval(qml.Hermitian(self.projector, range(self.features)))
        return quantum_circuit

    @staticmethod
    def _generate_pairs(X):
        """
        Generate Pairs Implementation
        """
        x1, x2 = [], []
        for i in range(X.shape[0]):
            for j in range(X.shape[0]):
                x1.append(X[i])
                x2.append(X[j])
        return np.array(x1), np.array(x2)

    def fit(self, X, y):
        """
        Quantum Kernel Training
        """
        self.X_train = X

        self.sample_indices = [np.random.choice(X.shape[0], self.samples) for i in range(self.estimators)]
        self.feature_indices = [np.random.choice(X.shape[1], self.features, False) for i in range(self.estimators)]

        vectorised_quantum_kernel = jax.vmap(self._quantum_kernel())
        jit_vectorised_quantum_kernel = jax.jit(vectorised_quantum_kernel)

        for i in range(self.estimators):
            x1, x2 = self._generate_pairs(X[self.sample_indices[i]][:, self.feature_indices[i]])
            self.projector = np.zeros([2**self.features, 2**self.features])
            self.projector[0, 0] = 1

            gram_matrix = jit_vectorised_quantum_kernel(x1, x2).block_until_ready()
            self.ensemble_estimator.append(self.base_estimator.fit(gram_matrix.reshape(self.samples, self.samples), y[self.sample_indices[i]]))

        return self

    def predict(self, X):
        """
        Quantum Kernel Predictions
        """
        if len(self.ensemble_estimator) != self.estimators:
            raise RuntimeError('Model has not been trained, please call fit() before predict()')
        confidences = self.predict_proba(X)
        return np.array([self.classes_[0] if confidences[i][0] > 0.5 else self.classes_[1] for i in range(len(X))])

    def predict_proba(self, X):
        """
        Quantum Kernel Confidences
        """
        if len(self.ensemble_estimator) != self.estimators:
            raise RuntimeError('Model has not been trained, please call fit() before predict()')
        vectorised_quantum_kernel = jax.vmap(self._quantum_kernel())
        jit_vectorised_quantum_kernel = jax.jit(vectorised_quantum_kernel)
        confidences = []
        for x in X:
            predictions = []
            for i in range(self.estimators):
                x1 = np.tile(x[self.feature_indices[i]], (self.samples, 1))
                x2 = self.X_train[self.sample_indices[i]][:, self.feature_indices[i]]
                self.projector = np.zeros([2**self.features, 2**self.features])
                self.projector[0, 0] = 1
                gram_matrix = jit_vectorised_quantum_kernel(x1, x2).block_until_ready()
                predictions.append(self.ensemble_estimator[i].predict_proba(gram_matrix.reshape(1, -1)))
            confidences.append(np.mean(predictions, 0))
        return np.array(confidences).reshape(-1, 2)
